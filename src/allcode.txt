// main.cpp

#include <iostream>
#include <vector>
#include <random>
#include <algorithm>
#include <raylib.h>

// Project headers
#include "game/Game.h"
#include "game/Snake.h"
#include "neat/NEAT.h"
#include "neat/Network.h"
#include "render/Renderer.h"

int main() {
    // ------------------------------------------------------------------------
    // Simulation parameters 
    // ------------------------------------------------------------------------
    const int GRID_W       = 10;    ///< grid width  (cells)
    const int GRID_H       = 10;    ///< grid height (cells)
    const int MAX_TICKS    = 400;   ///< max steps per simulation

    const int POP_SIZE     = 1000;    ///< genomes per generation
    const int INPUT_N      = 7;     ///< network input size (hx, hy, fx, fy)
    const int OUTPUT_N     = 4;     ///< network outputs (UP,DOWN,LEFT,RIGHT)
    const int GENERATIONS  = 1000;   ///< total training generations

    // ------------------------------------------------------------------------
    // Rendering parameters
    // ------------------------------------------------------------------------
    const int SCREEN_W = 1200;       ///< game width  (pixels)
    const int SCREEN_H = 600;       ///< game height (pixels)

    // ------------------------------------------------------------------------
    // Initialize core systems
    // ------------------------------------------------------------------------
    game::Game     game(GRID_W, GRID_H, MAX_TICKS);
    neat::NEAT     neat(POP_SIZE, INPUT_N, OUTPUT_N);
    render::Renderer renderer(SCREEN_W, SCREEN_H, GRID_W, GRID_H);

    // ------------------------------------------------------------------------
    // Main generational loop
    // ------------------------------------------------------------------------
    while (!renderer.shouldClose() && neat.generation < GENERATIONS) {
        int gen = neat.generation;

        double totalFitness = 0.0;
        double maxFitness   = -1e9;
        int    bestIdx      = 0;

        // Evaluate every genome
        auto pop = neat.population();
        for (size_t i = 0; i < pop.size(); ++i) {
            neat::Genome* g = pop[i];

            // Build network from genome
            neat::Network net(*g);

            // Run simulation and get fitness + sampled path
            game::EvalResult res = game.evaluate(net);
            g->fitness = res.fitness;
            totalFitness += res.fitness;

            // Track the best genome index
            if (res.fitness > maxFitness) {
                maxFitness = res.fitness;
                bestIdx    = static_cast<int>(i);
            }
        }

        // Compute summary stats
        double avgFitness   = totalFitness / pop.size();
        int    speciesCount = static_cast<int>(neat.species().size());


        // --------------------------------------------------------------------
        // Visualization: re-evaluate best genome for path, then render a
        // single frame showing its sampled path + neural network + stats.
        // --------------------------------------------------------------------
        {
            neat::Genome* bestG = pop[bestIdx];
            neat::Network bestNet(*bestG);
            game::EvalResult bestRes = game.evaluate(bestNet);

            renderer.beginFrame();
            renderer.drawGrid();

            // Draw sampled head-positions (every 10 ticks) as a “snake”
            renderer.drawSnake(bestRes.bestPath);


            renderer.drawNetwork(bestNet);

            // Overlay generation stats on screen
            renderer.drawStats(
                gen,
                static_cast<float>(maxFitness),
                static_cast<float>(avgFitness),
                speciesCount
            );
            renderer.endFrame();
        }

        // --------------------------------------------------------------------
        // Speciate & reproduce to form the next generation
        // We pass a no-op evalFunc since fitness is already filled.
        // --------------------------------------------------------------------
        neat.epoch([](neat::Genome&){ /* already evaluated */ });
    }

    // ------------------------------------------------------------------------
    // FINAL DEMO: Best network plays Snake indefinitely until ESC
    // ------------------------------------------------------------------------
    {
        std::cout << "\n=== Training complete. Running final demonstration ===\n";
        neat::Genome* champion = neat.getBest();
        neat::Network  net(*champion);

        // Prepare demonstration environment
        game::Snake snake(GRID_W, GRID_H);
        std::mt19937 rng(std::random_device{}());
        std::uniform_int_distribution<int> distX(0, GRID_W - 1),
                                          distY(0, GRID_H - 1);
        game::Vec2i food{ distX(rng), distY(rng) };

        // Lambda to reset snake & respawn food
        auto resetSim = [&]() {
            snake.reset();
            food = { distX(rng), distY(rng) };
        };

        resetSim();
        SetTargetFPS(5);


        // Demo loop: restart on death, exit on ESC
        while (!renderer.shouldClose()) {
            // 1) Get normalized inputs
            auto head = snake.head();
            float hx = float(head.x) / GRID_W;
            float hy = float(head.y) / GRID_H;
            float fx = float(food.x - head.x) / GRID_W;
            float fy = float(food.y - head.y) / GRID_H;
            auto ray = snake.getRayCast();
            float left  = std::get<0>(ray);
            float front = std::get<1>(ray);
            float right = std::get<2>(ray);
            std::cout << "Inputs: "
              << "hx=" << hx << " "
              << "hy=" << hy << " "
              << "fx=" << fx << " "
              << "fy=" << fy << " "
              << "left=" << left << " "
              << "front=" << front << " "
              << "right=" << right << "\n";


            // 2) Feed network and update direction
            auto outputs = net.feed({ hx, hy, fx, fy, left, front, right});
            int dir = std::distance(
                outputs.begin(),
                std::max_element(outputs.begin(), outputs.end())
            );
            snake.setDirection(static_cast<game::Dir>(dir));

            // 3) Advance snake; if collision, reset
            if (!snake.update()) {
                resetSim();
            } else {
                // Check for food
                if (snake.head().x == food.x && snake.head().y == food.y) {
                    snake.grow();
                    food = { distX(rng), distY(rng) };
                }
            }

            // 4) Render game + network
            renderer.beginFrame();
            renderer.drawGrid();
            renderer.drawSnake(snake.body());
            renderer.drawFood(food.x, food.y);
            renderer.drawNetwork(net);  // network rendering next to grid
            renderer.endFrame();

            // 5) Exit on ESC
            if (IsKeyPressed(KEY_ESCAPE)) {
                break;
            }
        }
    }

    return 0;
}
// NeatConfig.h
#pragma once

namespace neat {

// Weight mutation:
//  - PROB_PERTURB:    % of weights to perturb vs. replace entirely
//  - PERTURB_STRENGTH: standard deviation of Gaussian for perturbation
constexpr float WEIGHT_PERTURB_PROB   = 0.8f;
constexpr float PERTURB_STRENGTH      = 0.2f;

// Structural mutation probabilities (used in NEAT::reproduce())
constexpr float PROB_ADD_CONNECTION   = 0.03f;
constexpr float PROB_ADD_NODE         = 0.01f;

// When a matching gene is disabled in either parent, re-enable it with this chance
constexpr float PROB_REENABLE_GENE    = 0.05f;

} // namespace neat
// InnovationTracker.h
#pragma once
#include <mutex>
#include <unordered_map>
#include <cstdint>
#include <string>

namespace neat {

// Forward declarations
using NodeId  = uint32_t;
using InnovId = uint64_t;

/**
 * @brief  Global, thread-safe innovation registry.
 * 
 * - Assigns unique innovation IDs to every new connection (from→to).
 * - Assigns unique node IDs when splitting existing connections, re-using
 *   the same node ID if the same connection is split again.
 * - Persists its state in a simple text file so IDs remain consistent
 *   across runs.
 */
class InnovationTracker {
public:
    /// Get the singleton instance
    static InnovationTracker& getInstance();

    /// Get (or create) the innovation number for a connection (from→to)
    InnovId getConnectionInnov(NodeId from, NodeId to);

    /// Get (or create) the new NodeId for splitting an existing connection
    /// whose innovation number is connInnov.
    NodeId getSplitNodeId(InnovId connInnov);

    /**
     * If your initial genomes define input IDs 0…inN-1 and output IDs
     * inN…inN+outN-1, call this *once* to ensure hidden-node IDs start
     * above that range.
     */
    void initializeNodeCounter(NodeId firstFreeId);

private:
    InnovationTracker();               // loads from disk
    ~InnovationTracker();              // saves to disk

    InnovationTracker(const InnovationTracker&)            = delete;
    InnovationTracker& operator=(const InnovationTracker&) = delete;

    mutable std::mutex mutex_;
    InnovId nextConnInnov_;
    NodeId  nextNodeId_;

    // key = (uint64_t(from)<<32)|uint32_t(to)
    std::unordered_map<uint64_t, InnovId> connInnovMap_;

    // key = original connection InnovId → NodeId of the split node
    std::unordered_map<InnovId, NodeId>   splitNodeMap_;

    const std::string dbFile_ = "innovation.db";
};

} // namespace neat
// InnovationTracker.cpp
#include "InnovationTracker.h"
#include <fstream>
#include <iostream>
#include <sstream>

namespace neat {

InnovationTracker& InnovationTracker::getInstance() {
    static InnovationTracker inst;
    return inst;
}

InnovationTracker::InnovationTracker()
  : nextConnInnov_(1),   // start at 1
    nextNodeId_(1)       // will be bumped by initializeNodeCounter()
{
    std::lock_guard<std::mutex> lk(mutex_);
    std::ifstream in(dbFile_);
    if (!in.is_open()) return;  // first run: no file yet

    size_t connCount, splitCount;
    in >> nextConnInnov_ >> nextNodeId_;
    in >> connCount;
    for (size_t i = 0; i < connCount; ++i) {
        uint64_t key; InnovId innov;
        in >> key >> innov;
        connInnovMap_[key] = innov;
    }
    in >> splitCount;
    for (size_t i = 0; i < splitCount; ++i) {
        InnovId connInnov; NodeId nid;
        in >> connInnov >> nid;
        splitNodeMap_[connInnov] = nid;
    }
}

InnovationTracker::~InnovationTracker() {
    std::lock_guard<std::mutex> lk(mutex_);
    std::ofstream out(dbFile_, std::ofstream::trunc);
    if (!out.is_open()) {
        std::cerr << "Failed to save innovation DB to “" << dbFile_ << "”\n";
        return;
    }
    // save counters
    out << nextConnInnov_ << " " << nextNodeId_ << "\n";
    // save connection map
    out << connInnovMap_.size() << "\n";
    for (auto& kv : connInnovMap_) {
        out << kv.first << " " << kv.second << "\n";
    }
    // save split-node map
    out << splitNodeMap_.size() << "\n";
    for (auto& kv : splitNodeMap_) {
        out << kv.first << " " << kv.second << "\n";
    }
}

InnovId InnovationTracker::getConnectionInnov(NodeId from, NodeId to) {
    std::lock_guard<std::mutex> lk(mutex_);
    uint64_t key = (uint64_t(from) << 32) | uint64_t(to);
    auto it = connInnovMap_.find(key);
    if (it != connInnovMap_.end()) return it->second;
    InnovId innov = nextConnInnov_++;
    connInnovMap_[key] = innov;
    return innov;
}

NodeId InnovationTracker::getSplitNodeId(InnovId connInnov) {
    std::lock_guard<std::mutex> lk(mutex_);
    auto it = splitNodeMap_.find(connInnov);
    if (it != splitNodeMap_.end()) return it->second;
    NodeId nid = nextNodeId_++;
    splitNodeMap_[connInnov] = nid;
    return nid;
}

void InnovationTracker::initializeNodeCounter(NodeId firstFreeId) {
    std::lock_guard<std::mutex> lk(mutex_);
    if (nextNodeId_ < firstFreeId) {
        nextNodeId_ = firstFreeId;
    }
}

} // namespace neat
// Game.h
#pragma once
#include "Snake.h"
#include <vector>
#include <random>

namespace game {

struct EvalResult {
    double fitness;
    std::vector<Vec2i> bestPath; // for visualization
};

class Game {
public:
    Game(int gridW, int gridH, int maxTicks);
    // Run one simulation for given neural network; return fitness & path
    template<typename NetworkT>
    EvalResult evaluate(NetworkT& net);
private:
    int gridW_, gridH_, maxTicks_;
   
};
} // namespace game
// Game.cpp
#include "Game.h"
#include "Snake.h"
#include <cmath>
#include <iostream>
#include <random> 
#include <algorithm>
using namespace game;

Game::Game(int w, int h, int maxT)
 : gridW_(w), gridH_(h), maxTicks_(maxT)
{

}

template<typename N>
EvalResult Game::evaluate(N& net) {
    // each thread gets its own RNG, seeded once
    static thread_local std::mt19937 local_rng(std::random_device{}());

    Snake snake(gridW_, gridH_);
    std::uniform_int_distribution<int> distX(0, gridW_-1),
                                     distY(0, gridH_-1);
    Vec2i food{distX(local_rng), distY(local_rng)};
    double fitness = 0;
    int ticksSinceLastFood = 0;
    std::vector<Vec2i> path;
    for (int t = 0; t < maxTicks_; ++t) {
        ticksSinceLastFood++;
        // prepare inputs: normalized head pos, food delta
        float hx = float(snake.head().x)/gridW_,
              hy = float(snake.head().y)/gridH_,
              fx = float(food.x - snake.head().x)/gridW_,
              fy = float(food.y - snake.head().y)/gridH_;
        auto ray = snake.getRayCast();
        float left  = std::get<0>(ray);
        float front = std::get<1>(ray);
        float right = std::get<2>(ray);

        auto outputs = net.feed({hx, hy, fx, fy, left, front, right});
        // pick largest output -> direction
        int dir = std::distance(outputs.begin(),
            std::max_element(outputs.begin(), outputs.end()));
        snake.setDirection(static_cast<Dir>(dir));
        if (!snake.update()) break;  // died
        // ate food?
        if (snake.head().x == food.x && snake.head().y == food.y) {
            snake.grow();
            fitness += 10.0;
            food = {distX(local_rng), distY(local_rng)};
            ticksSinceLastFood = 0;
        }
        if (ticksSinceLastFood >= 10) {
            fitness -= 0.001;
        }
        // incremental fitness: survival + closeness to food
        double dist = std::hypot(food.x - snake.head().x, food.y - snake.head().y);
        fitness += 1.0 - (dist / std::hypot(gridW_, gridH_));
        
        path.push_back(snake.head());
    }
    return {fitness, path};
}

#include "neat/Network.h"

namespace game {
  // force MSVC to emit the evaluate<Network> symbol
  template EvalResult Game::evaluate<neat::Network>(neat::Network& net);
}

// Explicit instantiation for our Network type will go in main.cpp.
// Snake.h
#pragma once
#include <vector>
#include <raylib.h>

namespace game {

enum class Dir { UP, DOWN, LEFT, RIGHT };

struct Vec2i { 
    int x, y; 
    bool operator==(const Vec2i& other) const {
        return x == other.x && y == other.y;
    }
};

class Snake {
public:
    Snake(int gridW, int gridH);
    void reset();
    void setDirection(Dir d);
    std::tuple<float, float, float> getRayCast() const;
    bool update(); // returns false on collision
    const std::vector<Vec2i>& body() const;
    Vec2i head() const;
    void grow();
private:
    int gridW_, gridH_;
    std::vector<Vec2i> segments_;
    Dir dir_;
    bool growNext_;
};

} // namespace game
// Snake.cpp
#include "Snake.h"
#include <iostream>
using namespace game;

Snake::Snake(int w, int h)
 : gridW_(w), gridH_(h), dir_(Dir::RIGHT), growNext_(false)
{
    reset();
}

void Snake::reset() {
    segments_.clear();
    segments_.push_back({gridW_/2, gridH_/2});
    dir_ = Dir::RIGHT;
    growNext_ = false;
}

void Snake::setDirection(Dir d) {
    // prevent reverse
    if ((dir_ == Dir::UP && d == Dir::DOWN) ||
        (dir_ == Dir::DOWN && d == Dir::UP) ||
        (dir_ == Dir::LEFT && d == Dir::RIGHT) ||
        (dir_ == Dir::RIGHT && d == Dir::LEFT))
        return;
    dir_ = d;
}



std::tuple<float, float, float> Snake::getRayCast() const {
    auto isBlocked = [&](Vec2i pos) {
        // Check wall
        if (pos.x < 0 || pos.x >= gridW_ || pos.y < 0 || pos.y >= gridH_)
            return true;
        // Check body
        for (const auto& seg : segments_)
            if (seg == pos)
                return true;
        return false;
    };

    // Directions relative to current
    Vec2i fwd, lft, rgt;
    switch (dir_) {
        case Dir::UP:    fwd = {0, -1}; lft = {-1, 0}; rgt = {1, 0}; break;
        case Dir::DOWN:  fwd = {0, 1};  lft = {1, 0};  rgt = {-1, 0}; break;
        case Dir::LEFT:  fwd = {-1, 0}; lft = {0, 1};  rgt = {0, -1}; break;
        case Dir::RIGHT: fwd = {1, 0};  lft = {0, -1}; rgt = {0, 1};  break;
    }

    auto checkDir = [&](Vec2i dirVec) -> float {
        Vec2i pos = head();
        for (int i = 1; i <= 3; ++i) {
            pos.x += dirVec.x;
            pos.y += dirVec.y;
            if (isBlocked(pos))
                return (i - 1) / 3.0f;
        }
        return 1.0f;
    };

    float leftDist   = checkDir(lft);
    float frontDist  = checkDir(fwd);
    float rightDist  = checkDir(rgt);

    return {leftDist, frontDist, rightDist};
}


bool Snake::update() {
    Vec2i head = segments_.front();
    switch (dir_) {
        case Dir::UP:    head.y--; break;
        case Dir::DOWN:  head.y++; break;
        case Dir::LEFT:  head.x--; break;
        case Dir::RIGHT: head.x++; break;
    }
    // wall collision
    if (head.x < 0 || head.x >= gridW_ || head.y < 0 || head.y >= gridH_){
        //std::cout << "wall" << std::endl;
        return false;
    }
    // self collision
    for (auto& s : segments_)
        if (s.x == head.x && s.y == head.y){
            //std::cout << "self" << std::endl;
            return false;
        }
    segments_.insert(segments_.begin(), head);
    if (growNext_) {
        growNext_ = false;
    } else {
        segments_.pop_back();
    }
    return true;
}

void Snake::grow() { growNext_ = true; }

const std::vector<Vec2i>& Snake::body() const { return segments_; }
Vec2i Snake::head() const { return segments_.front(); }
// Renderer.h
#pragma once
#include <vector>
#include "game/Snake.h"
#include "neat/Network.h"

namespace render {

class Renderer {
public:
    Renderer(int screenW, int screenH, int gridW, int gridH);
    ~Renderer();
    void beginFrame();
    void drawGrid();
    void drawSnake(const std::vector<game::Vec2i>& body);
    void drawFood(int x, int y);
    void drawNetwork(const neat::Network& net);
    void drawStats(int gen, float maxF, float avgF, int speciesCount);
    void endFrame();
    bool shouldClose();
    void processUI(bool& paused, float& speed, int& observeIdx);
private:
    int screenW_, screenH_, gridW_, gridH_;
};

} // namespace render
// Renderer.cpp

#include "Renderer.h"
#include <unordered_map>
#include <cstdio>      // for snprintf
#include <cmath>       // for std::fabs

#include "game/Snake.h" 
#include <raylib.h>
#include <algorithm>
#include <iostream>
using namespace render;
using namespace game;
using namespace neat;

Renderer::Renderer(int sw, int sh, int gw, int gh)
 : screenW_(sw), screenH_(sh), gridW_(gw), gridH_(gh)
{
    InitWindow(sw, sh, "Snake NEAT");
    SetTargetFPS(0);
}

Renderer::~Renderer(){
    CloseWindow();
}

void Renderer::beginFrame() { BeginDrawing(); ClearBackground(RAYWHITE); }
void Renderer::endFrame()   { EndDrawing(); }
bool Renderer::shouldClose(){ return WindowShouldClose(); }

void Renderer::drawGrid(){
    float cellW = float(screenW_/2)/gridW_, cellH = float(screenH_)/gridH_;
    
    for (int x = 0; x <= gridW_; ++x) {
        // cast ints to float so no narrowing in {}
        DrawLineV({ x * cellW, 0.0f },
                  { x * cellW, static_cast<float>(screenH_) },
                  LIGHTGRAY);
    }
    for (int y = 0; y <= gridH_; ++y) {
        DrawLineV({ 0.0f, y * cellH },
                  { static_cast<float>(screenW_/2), y * cellH },
                  LIGHTGRAY);
    }
}

void Renderer::drawSnake(const std::vector<game::Vec2i>& body) {
    float cellW = static_cast<float>(screenW_/2) / gridW_;
    float cellH = static_cast<float>(screenH_) / gridH_;
    for (auto& s : body) {
        DrawRectangle(
            static_cast<int>(s.x * cellW),
            static_cast<int>(s.y * cellH),
            static_cast<int>(cellW),
            static_cast<int>(cellH),
            GREEN
        );
    }
}


void Renderer::drawFood(int x, int y){
    float cellW = float(screenW_/2)/gridW_, cellH = float(screenH_)/gridH_;
    DrawRectangle(x*cellW, y*cellH, cellW, cellH, RED);
}

void Renderer::drawNetwork(const Network& net) {
    // Get the current genome (structure) and activations (neuron outputs)
    const auto& genome      = net.getGenome();
    const auto& activations = net.getActivations();

    // Separate all nodes into input, hidden, and output node ID lists
    std::vector<NodeId> inputs, hidden, outputs;
    for (const auto& kv : genome.nodes) {
        switch (kv.second.type) {
            case NodeGene::INPUT:  inputs.push_back(kv.first);  break;
            case NodeGene::BIAS:  inputs.push_back(kv.first);  break;
            case NodeGene::HIDDEN: hidden.push_back(kv.first);  break;
            case NodeGene::OUTPUT: outputs.push_back(kv.first); break;
        }
    }

    // Define the region on screen to draw the network (right 35% of window)
    float areaX = screenW_ * 0.55f;
    float areaY = screenH_ * 0.1f;
    float areaW = screenW_ * 0.4f;
    float areaH = screenH_ * 0.8f;

    // ---- Topological sort (layout columns) ----

    // 1. Initialize a "depth" map for all nodes
    //    Inputs always start at depth=0, hidden start at 1, outputs set later
    std::unordered_map<NodeId, int> depth;
    for (NodeId id : inputs)  depth[id] = 0;
    for (NodeId id : hidden)  depth[id] = 1;

    // 2. Propagate depths: for each enabled connection (not to outputs), 
    //    set the destination node's depth to at least one more than the source node
    int maxIters = static_cast<int>(genome.nodes.size());
    for (int iter = 0; iter < maxIters; ++iter) {
        bool anyChange = false;
        for (const auto& kv : genome.connections) {
            const auto& cg = kv.second;
            if (!cg.enabled) continue; // Only layout enabled connections

            // Ensure both source and target nodes exist
            auto fromIt = genome.nodes.find(cg.from);
            auto   toIt = genome.nodes.find(cg.to);
            if (fromIt == genome.nodes.end() || toIt == genome.nodes.end())
                continue; // skip if nodes are missing (shouldn't happen)

            // Only propagate depth to non-output nodes
            if (toIt->second.type == NodeGene::OUTPUT)
                continue;

            int d_from = depth[cg.from];      // Current depth of source node
            int& d_to  = depth[cg.to];        // Reference to depth of target node
            int want   = d_from + 1;          // The minimum depth the target should be
            if (d_to < want) {                // If we need to bump up its depth...
                d_to = want;                  // ...set it, and
                anyChange = true;             // ...note that something changed
            }
        }
        if (!anyChange) break; // Once no more changes, we're done
    }

    // 3. Find the maximum hidden depth reached (for # of columns)
    int maxHiddenDepth = 1;
    for (NodeId id : hidden)
        maxHiddenDepth = std::max(maxHiddenDepth, depth[id]);

    // 4. Calculate the number of layers/columns:
    //    (input layer) + (hidden layers) + (output layer)
    int totalLayers = maxHiddenDepth + 2; // +2 for input and output columns

    // 5. Bucket all nodes into their display columns ("layers")
    std::vector<std::vector<NodeId>> layers(totalLayers); // One vector per column
    for (NodeId id : inputs)
        layers[0].push_back(id); // Inputs in first column
    for (NodeId id : hidden)
        layers[depth[id]].push_back(id); // Hidden in their computed columns
    for (NodeId id : outputs)
        layers[totalLayers - 1].push_back(id); // Outputs in last column

    // 6. Assign screen coordinates for each node, spacing evenly vertically within its layer
    std::unordered_map<NodeId, Vector2> positions;
    for (int layerIdx = 0; layerIdx < totalLayers; ++layerIdx) {
        // Compute the x position for this layer/column
        float x = areaX + areaW * (float(layerIdx) / float(totalLayers - 1));
        auto& bucket = layers[layerIdx];
        std::sort(bucket.begin(), bucket.end()); // Sort for visual consistency

        size_t count = bucket.size(); // How many nodes in this layer
        for (size_t i = 0; i < count; ++i) {
            // Spread the nodes vertically, with equal spacing
            float y = areaY + areaH * (float(i + 1) / float(count + 1));
            positions[bucket[i]] = { x, y };
        }
    }

    // ---- Draw all enabled connections (edges) ----
    for (const auto& kv : genome.connections) {
        const auto& cg = kv.second;
        if (!cg.enabled) continue; // Only draw enabled connections

        // Find source and destination coordinates
        auto itA = positions.find(cg.from);
        auto itB = positions.find(cg.to);
        if (itA == positions.end() || itB == positions.end())
            continue; // Don't draw if one node is missing (shouldn't happen)

        // Draw the connection as a line (gray)
        DrawLineV(itA->second, itB->second, LIGHTGRAY);
    }

    // ---- Draw all nodes (neurons) ----
    const float nodeR = 5.0f; // Radius of each node's circle
    for (const auto& kv : positions) {
        NodeId id = kv.first;      // The node's ID
        Vector2 pos = kv.second;   // Its screen position

        // Look up activation value (or 0 if not found)
        float act = 0.0f;
        auto it = activations.find(id);
        if (it != activations.end())
            act = it->second;

        // Color: green for positive activation, red for negative, intensity is abs(activation)
        unsigned char inten = static_cast<unsigned char>(200 * std::fabs(act));
        Color col = (act >= 0.0f)
            ? Color{0, inten, 0, 255}
            : Color{inten, 0, 0, 255};

        // Draw filled circle
        DrawCircleV(pos, nodeR, col);

        // Draw outline
        DrawCircleLines(int(pos.x), int(pos.y), nodeR, BLACK);

        // Draw the activation value as text next to the node
        char buf[32];
        snprintf(buf, sizeof(buf), "%.2f", act);
        DrawText(buf,
                 int(pos.x + nodeR + 2),
                 int(pos.y - 8),
                 10,
                 BLACK);
    }
}


void Renderer::drawStats(int gen, float maxF, float avgF, int speciesCount){
    DrawText(TextFormat("Gen: %d  MaxF: %.1f  AvgF: %.1f  Species: %d",
             gen, maxF, avgF, speciesCount), 10, 10, 20, BLACK);
}

void Renderer::processUI(bool& paused, float& speed, int& observeIdx){
    // e.g. keys to pause, speed up/down, change observed individual
    if (IsKeyPressed(KEY_SPACE)) paused = !paused;
    if (IsKeyPressed(KEY_UP)) speed = std::min(speed*2, 64.0f);
    if (IsKeyPressed(KEY_DOWN)) speed = std::max(speed/2, 0.25f);
    if (IsKeyPressed(KEY_RIGHT)) observeIdx++;
    if (IsKeyPressed(KEY_LEFT)) observeIdx--;
}
// Genome.h
#pragma once
#include "Gene.h"
#include <vector>
#include <map>

namespace neat {

struct Genome {
    std::map<InnovId, ConnectionGene> connections;
    std::map<NodeId, NodeGene> nodes;
    float fitness = 0.0f;
    // mutation/crossover APIs
    void mutateAddConnection();
    void mutateAddNode();
    void mutateWeights();
    static Genome crossover(const Genome& a, const Genome& b);
};

} // namespace neat
// Genome.cpp
#include "Genome.h"
#include "InnovationTracker.h"
#include "NeatConfig.h"
#include <random>
#include <algorithm>
#include <set>
#include <iostream>

namespace neat {

static std::mt19937 rng{std::random_device{}()};
static std::uniform_real_distribution<float> uni(-1.0f,1.0f);

void Genome::mutateWeights() {
    static std::normal_distribution<float> perturbDist(0.0f, PERTURB_STRENGTH);
    for (auto& kv : connections) {
        float r = uni(rng);
        if (r < WEIGHT_PERTURB_PROB) {
            // tweak existing weight
            kv.second.weight += perturbDist(rng);
        } else {
            // assign new weight
            kv.second.weight  = uni(rng);
        }
    }
}

void Genome::mutateAddConnection() {
    // gather all node IDs
    std::vector<NodeId> ids;
    ids.reserve(nodes.size());
    for (auto& kv : nodes) ids.push_back(kv.first);

    std::uniform_int_distribution<size_t> di(0, ids.size()-1);
    for (int tries = 0; tries < 10; ++tries) {
        NodeId a = ids[di(rng)], b = ids[di(rng)];
        if (a == b) continue;
        // never connect *into* an input
        if (nodes[b].type == NodeGene::INPUT || nodes[b].type == NodeGene::BIAS) continue;
        // skip existing
        bool exists = false;
        for (auto& ck : connections)
            if (ck.second.from == a && ck.second.to == b) { exists = true; break; }
        if (exists) continue;

        InnovId innov = InnovationTracker::getInstance().getConnectionInnov(a, b);
        connections[innov] = { innov, a, b, uni(rng), true };
        return;
    }
}


void Genome::mutateAddNode() {
    if (connections.empty()) return;

    // pick a random enabled connection
    auto it = connections.begin();
    std::advance(it, std::uniform_int_distribution<size_t>(0, connections.size()-1)(rng));
    ConnectionGene cg = it->second;
    if (!cg.enabled) return;

    // disable the old link
    connections[cg.innov].enabled = false;

    // fetch or create the new hidden node ID
    NodeId newId = InnovationTracker::getInstance().getSplitNodeId(cg.innov);
    nodes[newId] = { newId, NodeGene::HIDDEN };

    // create two new connections: from→new, new→to
    InnovId in1 = InnovationTracker::getInstance().getConnectionInnov(cg.from, newId);
    InnovId in2 = InnovationTracker::getInstance().getConnectionInnov(newId,   cg.to);
    connections[in1] = { in1, cg.from, newId,   1.0f,      true };
    connections[in2] = { in2,   newId,   cg.to,   cg.weight, true };
}


Genome Genome::crossover(const Genome& g1, const Genome& g2) {
    // Determine fitter parent (or random if tie)
    const Genome *fit, *oth;
    if      (g1.fitness > g2.fitness) { fit = &g1; oth = &g2; }
    else if (g2.fitness > g1.fitness) { fit = &g2; oth = &g1; }
    else {  // tie: pick randomly
        if (uni(rng) < 0.5f) { fit = &g1; oth = &g2; }
        else                 { fit = &g2; oth = &g1; }
    }

    Genome child;
    // 1) copy all node genes from fitter parent
    child.nodes = fit->nodes;

    // 2) gather all innovation IDs
    std::set<InnovId> allInnov;
    for (auto& kv : fit->connections) allInnov.insert(kv.first);
    for (auto& kv : oth->connections) allInnov.insert(kv.first);

    std::uniform_real_distribution<float> coin(0.0f, 1.0f);

    // 3) for each gene ID, decide inheritance
    for (InnovId innov : allInnov) {
        auto itF = fit->connections.find(innov);
        auto itO = oth->connections.find(innov);

        if (itF != fit->connections.end() && itO != oth->connections.end()) {
            // matching gene: pick randomly
            const ConnectionGene *src =
                (coin(rng) < 0.5f ? &itF->second : &itO->second);
            child.connections[innov] = *src;

            // handle disabled → re-enable chance
            if (!itF->second.enabled || !itO->second.enabled) {
                bool enable = (coin(rng) < PROB_REENABLE_GENE);
                child.connections[innov].enabled = true;
            }

        } else if (itF != fit->connections.end()) {
            // disjoint or excess from fitter parent
            child.connections[innov] = itF->second;
        }
        // else: gene only in less-fit parent → skip
    }
    return child;
}

} // namespace neat
// NEAT.h
#pragma once
#include "Genome.h"
#include "Network.h"
#include "Species.h"
#include <vector>
#include <random>
#include <functional>

namespace neat {

struct NEAT {
    NEAT(int popSize, int inN, int outN);
    ~NEAT();
    void epoch(std::function<void(Genome&)> evalFunc);
    Genome* getBest() const;
    const std::vector<Species>& species() const { return species_; }
    int generation = 0;
    const std::vector<Genome*>& population() const { return population_; }
private:
    int popSize_;
    std::vector<Genome*> population_;
    std::vector<Species> species_;
    std::mt19937 rng_;
    void speciate();
    void reproduce();
};

} // namespace neat
// NEAT.cpp
#include "NEAT.h"
#include "InnovationTracker.h"
#include "NeatConfig.h"
#include <algorithm>
#include <cmath>
#include <random>
#include <iostream>
using namespace neat;

static constexpr float C1=1.0f, C2=1.0f, C3=0.4f, COMPAT_THRESH=3.0f;

NEAT::NEAT(int popSize, int inN, int outN)
 : popSize_(popSize), rng_(std::random_device{}())
{
    // --- 1) Decide on node ID ranges ---
    // Inputs:    [0 .. inN-1]
    // Bias:      [inN]
    // Outputs:   [inN+1 .. inN+outN]
    NodeId biasId        = inN;
    NodeId firstOutputId = inN + 1;
    NodeId nextFreeId    = inN + 1 + outN;

    // Tell the tracker not to hand out any node IDs < nextFreeId
    InnovationTracker::getInstance().initializeNodeCounter(nextFreeId);

    // Uniform random weight initializer in [-1, +1]
    std::uniform_real_distribution<float> weightDist(-1.0f, 1.0f);

    // --- 2) Create initial population ---
    for (int i = 0; i < popSize_; ++i) {
        Genome* g = new Genome();

        // 2a) Add all input nodes
        for (NodeId nid = 0; nid < inN; ++nid) {
            g->nodes[nid] = { nid, NodeGene::INPUT };
        }
        // 2b) Add the bias node
        g->nodes[biasId] = { biasId, NodeGene::BIAS };

        // 2c) Add all output nodes
        for (NodeId j = 0; j < outN; ++j) {
            NodeId outId = firstOutputId + j;
            g->nodes[outId] = { outId, NodeGene::OUTPUT };
        }

        // 2d) Fully connect each input + bias → every output
        for (NodeId src = 0; src <= inN; ++src) {            // 0..inN = inputs + bias
            for (NodeId dst = firstOutputId; 
                 dst < firstOutputId + outN; 
                 ++dst) 
            {
                // Ask the global tracker for a unique innovation number
                InnovId innov = InnovationTracker::getInstance()
                                     .getConnectionInnov(src, dst);

                // Create the connection with a random initial weight
                float w = weightDist(rng_);
                g->connections[innov] = { innov, src, dst, w, true };
            }
        }

        population_.push_back(g);
    }
}


NEAT::~NEAT() {
    for (auto* g: population_) delete g;
}

void NEAT::epoch(std::function<void(Genome&)> evalFunc) {

    // evaluate
    for (auto* g : population_) {
        evalFunc(*g);
    }
    // sort by fitness descending
    std::sort(population_.begin(), population_.end(),
              [](Genome* a, Genome* b){ return a->fitness > b->fitness; });
    // speciate & reproduce
    speciate();
    reproduce();
    generation++;
}

Genome* NEAT::getBest() const {
    return population_.front();
}

void NEAT::speciate() {
    for (auto& s : species_) s.reset();
    species_.clear();
    for (auto* g : population_) {
        bool placed = false;
        for (auto& s : species_) {
            // compatibility = ??? (stub, always join first)
            placed = true;
            s.members.push_back(g);
            break;
        }
        if (!placed) {
            species_.push_back(Species());
            species_.back().members.push_back(g);
        }
    }
}

void NEAT::reproduce() {
    std::vector<Genome*> newPop;
    // elitism: keep top 2
    newPop.push_back(population_[0]);
    newPop.push_back(population_[1]);
    std::uniform_real_distribution<float> uni(0,1);
    while ((int)newPop.size() < popSize_) {
        // tournament select parents
        Genome* a = population_[std::uniform_int_distribution<int>(0,popSize_/2)(rng_)];
        Genome* b = population_[std::uniform_int_distribution<int>(0,popSize_/2)(rng_)];
        if (a->fitness < b->fitness) std::swap(a,b);
        Genome* child = new Genome(Genome::crossover(*a,*b));
        child->mutateWeights();
        if (uni(rng_) < PROB_ADD_CONNECTION) {
            child->mutateAddConnection();
        }
        if (uni(rng_) < PROB_ADD_NODE){
               child->mutateAddNode();
        }
        newPop.push_back(child);
    }
    // delete old non-elite
    for (size_t i=2; i<population_.size(); ++i) delete population_[i];
    population_.swap(newPop);
}
// Network.h
#pragma once
#include "Gene.h"
#include "Genome.h"
#include <vector>
#include <unordered_map> 

namespace neat {

class Network {
public:
    explicit Network(const Genome& g);
    // Feedforward: inputs → outputs; records per-node activations
    std::vector<float> feed(const std::vector<float>& in);

    // Access the last activation values by node ID
    const std::unordered_map<NodeId, float>& getActivations() const { return activations_; }

    // Access genome for structure
    const Genome& getGenome() const { return genome_; }

private:
    const Genome& genome_;
    std::vector<NodeId> topoOrder_;
    std::unordered_map<NodeId, float> activations_;  // recorded after feed
    void buildTopology();
};

} // namespace neat
// Network.cpp
#include "Network.h"
#include <unordered_map>
#include <queue>
#include <cmath>
#include <iostream>
using namespace neat;

Network::Network(const Genome& g)
 : genome_(g)
{
    buildTopology();
}

void Network::buildTopology() {
    // simple Kahn’s algorithm: nodes with no incoming edges first
    std::unordered_map<NodeId,int> indeg;
    for (auto& kv : genome_.nodes) indeg[kv.first] = 0;
    for (auto& kv : genome_.connections) if (kv.second.enabled)
        indeg[kv.second.to]++;
    std::queue<NodeId> q;
    for (auto& kv : indeg) if (kv.second==0) q.push(kv.first);
    while (!q.empty()) {
        NodeId n = q.front(); q.pop();
        topoOrder_.push_back(n);
        for (auto& kv : genome_.connections) {
            auto& cg = kv.second;
            if (cg.enabled && cg.from==n) {
                if (--indeg[cg.to]==0) q.push(cg.to);
            }
        }
    }
}

std::vector<float> Network::feed(const std::vector<float>& in) {
    std::unordered_map<NodeId,float> values;
    size_t i = 0;
    // 1) initialize all node values
    for (auto& kv : genome_.nodes) {
        auto type = kv.second.type;
        if (type == NodeGene::INPUT)
            values[kv.first] = in.at(i++);
        else if (type == NodeGene::BIAS)
            values[kv.first] = 1.0f;
        else
            values[kv.first] = 0.0f;
    }

    // 2) propagate in topological order
    for (NodeId nid : topoOrder_) {
        float v = values[nid];
        for (auto& ck : genome_.connections) {
            auto& cg = ck.second;
            if (cg.enabled && cg.from == nid) {
                values[cg.to] += v * cg.weight;
            }
        }

        // 3) activation — guard the at()
        auto nodeIt = genome_.nodes.find(nid);
        if (nodeIt == genome_.nodes.end()) {
            // this should never happen if your genome is consistent,
            // but we skip it to avoid the crash:
            continue;
        }
        auto type = nodeIt->second.type;
        if (type == NodeGene::HIDDEN || type == NodeGene::OUTPUT) {
            values[nid] = std::tanh(values[nid]);
        }
    }
    activations_ = values;

    // 4) collect outputs
    std::vector<float> out;
    for (auto& kv : genome_.nodes) {
        if (kv.second.type == NodeGene::OUTPUT) {
            out.push_back(values[kv.first]);
        }
    }
    return out;
}
// Gene.h
#pragma once
#include <cstdint>

namespace neat {

using NodeId = uint32_t;
using InnovId = uint64_t;

// NodeGene: id and type (input, hidden, output)
struct NodeGene {
    NodeId id;
    enum Type { INPUT, BIAS, HIDDEN, OUTPUT } type;
};

// ConnectionGene: from, to, weight, enabled, innovation number
struct ConnectionGene {
    InnovId innov;
    NodeId from, to;
    float weight;
    bool enabled;
};

} // namespace neat
// Species.h
#pragma once
#include "Genome.h"
#include <vector>

namespace neat {

struct Species {
    std::vector<Genome*> members;
    Genome* best = nullptr;
    void reset() { members.clear(); best = nullptr; }
};

} // namespace neat